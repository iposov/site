-- Ленивые вычисления
a = mod 100 0
-- Хаскель не сделает вычисление, выполняя эту строчку
-- он только запомнит, какое выражение надо вычислить, чтобы узнать a
-- Само вычисление произойдет только тогда, когда значение реально
-- понадобится
b = a + 1
-- даже сейчас ничего не вычислилось, для b сохранено только то,
-- как его вычислять

-- Ленивость, делаем не сразу, а только когда стало нужно
-- Это оптимизирует вычисления, мы не делаем лишних вычислений
-- Но это требует память для хранения всех выражений,
-- труднее отлаживать производительность, не всегда очевидно,
-- когда происходят вычисления.

-- Когда происходит вычисление? Основной и самый распространенный
-- случай: при операции ввода/вывода, например, печати на экран.
-- Есть другие ситуации, см. дальше

-- Что еще дает ленивость.
ones :: [Int]
ones = 1 : ones

h1 = head ones -- голова списка, это 1
h2 = take 5 ones -- первые пять элементов списка

-- ones это бесконечный список из единиц.
-- его еще так можно составить:
-- [1,1..]

fib :: [Int]
fib = 1 : 1 : (zipWith (+) fib (tail fib))
-- fib            = 1 1 2 3 5 8 13 ...
-- tail fib       = 1 2 3 5 8 13 ...
-- fib + tail fib = 2 3 5 8 13

-- (+) это функция сложения, в скобках пишем, чтобы она работала
-- как функция
-- (+) 2 30

-- Была задача проверка на простоту через вычисление делителей
divs :: Int -> [Int] -- список делителей числа
divs n = filter (\x -> mod n x == 0) [1..n]

isPrime :: Int -> Bool
isPrime n = divs n == [1, n]

-- сколько делается вычислений, чтобы проверить, что 100 не простое?
-- Если бы не было ленивых вычислений, было бы 100 проверок для построения
-- списка делителей.
-- В Haskell при ленивых вычислениях:
-- сравниваем списки. Проверяем равен ли 1 первому элементу divs.
-- первый элемент divs находится быстро, это единица всегда. Провеяем
-- второй делитель. Второй делитель в divs оказывается равен 2. И это
-- не тоже самое, что 100. Сразу результат: 100 не простое.
-- Получается, что мы даже не пытались вычислять делители 100 после 
-- 2. Т.е. проверка на простоту для составных чисел всегда будет
-- работать быстро, никогда не будут все делители вычислены до конца.
-- У составного числа всегда есть делитель, меньше его корня,
-- значит, такая проверка на простоту работает не дольше, чем sqrt(n)

-- Когда еще происходят вычисления, кроме ввода/вывода.

-- При сопоставлении с образцом:
totext :: Integer -> String
totext 1 = "один"
totext 2 = "два"
totext _ = "много"

-- totext a не вычислится

-- $! это функция строгого применения (сравните $ это просто применить)
-- f $ a и f $! a это эквивалентно f a, но во втором случае a сначала
-- будет вычислено.

-- Последняя ситуация, когда вычисление происходит сразу, это
-- особенные параметры в алгебраических типах

data A = A Integer !Integer deriving Show
-- какой-то алгебраический тип, но перед вторым аргументом стоит !

a1 = A 10 (mod 100 0)
a2 = A (mod 100 0) 10

firstA :: A -> Integer
firstA (A a _) = a

secondA :: A -> Integer
secondA (A _ a) = a

-- secondA a1 выдает деление на 0. Потому что должен вернуться как раз
-- mod 100 0
-- secondA a2 не вычисляет mod 100 0, потому что нам это значение
-- не нужно
-- first a1, казалось бы, должен был бы выкинуть (mod 100 0),
-- потому что она сопоставляется с _ и не используется. Но
-- мы постаили ! перед вторым аргументом A: A Integer !Integer
-- значит, второе значение обязательно должно вычислиться. И
-- его так просто не проигнорировать.

-- Обычно, ошибку в вычислениях показывают не через mod 100 0
-- Использует встроенную функцию bottom: bottom = bottom
bottom = bottom
-- любая попытка вычислить bottom это ошибка.

