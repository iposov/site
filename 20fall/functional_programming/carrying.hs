-- Частичное применение, карринг

add :: Int -> Int -> Int
add x y = x + y

-- вместо add можно писать (+)
-- напоминание, следующее эквивалентно
-- 2 + 2
-- (+) 2 2
-- add 2 2
-- 2 `add` 2 -- в обратных кавычках

-- типы выражений
-- add :: Int -> Int -> Int
-- add 2 3 :: Int
-- add 2 :: ?????

f = add 2
g = f 4 -- f заменяется на add 2, получается f 2 4, т.е. 6
-- итого, add 2 это функция, ее можно применить к числу
-- и получить число, на два больше, чем заданное.

-- еще одно объяснение. add 2 4 равно (add 2) 4
-- получается, что add 2 :: Int -> Int

-- Если функцию применить не ко всем аргументам, получится
-- функция, которая требует оставшиеся аргументы.

-- Еще одно замечание. Можно считать, что в Haskell у всех
-- функций ровно один аргумент.

-- Есть простая и удобная запись частичных применений для 
-- инфиксных функций:

inc2 = (+2) -- это функция (+), у которой второй арг = 2
sub2 = (2-) -- это функция (-), у которой первый арг = 2
sub2p = (-2) -- как это записать, чтобы было
             -- вычитание со вторым аргументом 2,
             -- а не число -2
div2a = (2/) -- это функция (/), у которой первый аргумент 2
div2b = (/2) -- это функция (/), у которой второй аргумент 2
-- пользуемся так: div2a 10 = 0.2   div2b 10 = 5.0

add1 = (`add`1)

-- пользуйтесь секшонами, заменяйте \x -> x + 1 на (+1)

-- еще несколько полезных примеров частичных применений

c1 = (2:) -- это ...
          -- приписывает 2 в начало списка.
          -- c1 :: [Int] -> [Int]
-- c1 [10, 20, 30] получится [2, 10, 20, 30]

c2 = (++[10, 20, 30]) -- приписывает [10, 20, 30] в конец
                      -- списка.
                      
-- map (+1) [10, 20, 30] получается [11, 21, 31]
inclist1 = map (+1)
-- map :: (a -> b) -> [a] -> [b]
-- inclist :: [Int] -> [Int] -- подставили аргумент (a -> b)
-- inclist1 [10, 20, 30] вычисляется [11, 21, 31]

filterOdds = filter (\x -> mod x 2 == 1)
-- filterOdds [10, 15, 23, 50] это [15, 23]

-- Как бы мы написали это же раньше:
filterOdds2 :: [Int] -> [Int]
filterOdds2 list = filter (\x -> mod x 2 == 1) list

-- чем отличается предыдущая версия? Сокращением list
-- слева и справа
-- В общем случае, если вы пишете
-- func a b c = expression c
-- с можно сократить, получится
-- func a b = expression

-- Пример, не всегда можно легко записать частичное
-- применение, что если нужно подставить не первый аргумент,
-- а второй.

-- map (+1) -- не хватает второго аргумента map
-- map __ [10, 20, 30] -- как сделать такую функцию,
-- где надо подставлять первый аргумент

map102030' = \f -> map f [10, 20, 30]
map102030'' = (`map`[10, 20, 30])

-- сделаем функцию, которая меняет аргументы функции
rev2 :: (a -> b -> c) -> b -> a -> c
rev2 f x y = f y x

sub' = rev2 (-)      -- \x y -> y - x

map102030''' = (rev2 map) [10, 20, 30]
-- кстати, (add 1) 2 = add 1 2
-- поэтму (rev2 map) [10, 20, 30] = rev2 map [10, 20, 30]


map102030'''' = rev2 map [10, 20, 30]
-- здесь Haskell не справляется с выводом типов,
-- он считает, что map102030'''' :: (Integer -> b) -> [b]
-- на самом деле, 
-- map102030'''' :: Num b => (b -> a) -> [a]
-- т.е. имеется в виду, что не Integer, а любой числовой тип

-- Поэтому всегда пишите тип для функций верхнего уровня.
-- Иногда приходится писать типы и для внутренних функций

-- Две функции высшего порядка $ и .

-- $ это применение, определим сами как $*
($*) :: (a -> b) -> a -> b
f $* a = f a

-- зачем вообще такая функция?? Можно же просто применять
-- функцию к значению.
-- С ней иногда красивей записывается:
fact' :: Integer -> Integer
fact' n = helper 1 n where
                      helper a 0 = a
                      helper a n = helper (a * n) $ n - 1
                      -- helper a n = helper (a * n) (n - 1)
                   
fact'' :: Integer -> Integer
fact'' = helper 1 where -- сократили на n
                   helper a 0 = a
                   helper a n = helper (a * n) $ n - 1
                   -- helper a n = helper (a * n) (n - 1)
               
-- Функция . Композиция функций как в математике

(.*) :: (b -> c) -> (a -> b) -> (a -> c)
f .* g = \x -> f (g (x))       --  f(g(x)) = (f.g) (x)

p1m2 = (+1) . (*2) -- p1m2 10 = 21
m2p1 = (*2) . (+1) -- p1m2 10 = 22

is_odd :: Int -> Bool -- верно ли, что число нечетное?
-- is_odd x = mod x 2 == 1
-- is_odd x = (== 1) ((`mod`2) x)
is_odd = (== 1) . (`mod`2)
                      
                      
