f :: Int -> Int
f x = x + 1

g :: Int -> Int 
g x = x * 2

h :: Int -> Int -> Int
h x y = x + 2 * y

-- типы
-- Int, числа как в Java
-- Integer, числа как в Python, произвольной точности
-- Double, Float - вещественные числа, как в Java
-- Char - символ, в одинарных кавычках 'a'
-- Bool - логический, True или False
-- String, эквивалентно [Char] - последовательность символов
-- [Int], [Char], [String], [Double] - список Int, список Сhar и т.п.

-- напишем функцию "модуль"
abs1 :: Int -> Int
abs1 x = if x < 0 then -x else x -- if это выражение
-- if 2 > 3 then 10 else 20 вычисляется в 20
-- (if 2 > 3 then 10 else 20) + 7 вычисляется в 27

-- abs1 42 это 42
-- abs1 (-42) это 42, если abs1 -42 это воспринимается как вычитание

-- с использованием гардов (guard)
abs2 :: Int -> Int
abs2 x | x > 0   = x    
       | x <= 0  = -x
       
-- лучше использовать otherwise = True

-- с использованием гардов и otherwise
abs3 :: Int -> Int
abs3 x | x > 0   = x    
       | otherwise  = -x
       
-- Еще один пример, просто пример какой-то функции
-- при вычислении функции haskell последовательно подбирает
-- подходящее правило от начала к концу
s :: Int -> Int
s 0 = 10
s 1 = 20
s x | x > 5 = 100
s x = 42
-- если набор правил не исчерпывающий, случится ошибка при применении
-- к аргументам, для которых нет правил

-- Факториал. 5! = 1 * 2 * 3 * 4 * 5, 10! = 1 * 2 * 3 * ... * 10
-- 0! = 1, 1! = 1, 2! = 1 * 2 = 2
fact :: Integer -> Integer
fact 0 = 1
fact 1 = 1  -- лишняя строка
fact n = n * fact (n - 1)

-- как вычисляется fact 4:
-- fact 4 = 4 * fact 3
-- запускается вычисление fact 3: fact 3 = 3 * fact 2
-- запускается вычисление fact 2: fact 2 = 2 * fact 1
-- запускается вычисление fact 1: fact 1 = 1
-- теперь мы знаем, что fact 2 = 2 * 1 = 2
-- теперь мы знаем, что fact 3 = 3 * 2 = 6
-- теперь мы знаем, что fact 4 = 4 * 6 = 24 

-- списки. Будем для начала тренироваться на [Int]
-- как задать список:
-- [1, 2, 3]: в квадратных скобках через запятую
-- это на самом деле "синтаксический сахар", на самом деле списки
-- чуть другие.
-- [] - пустой список
--  операция : приписывает элемент в начало списка
-- 2 : [] эквивалентно [2]
-- 1 : 2 : [] - приписать сначала 2 к списку, потом 1
-- эквивалентно 1 : [2]
-- 0 : [10, 20, 30] получается [0, 10, 20, 30]
-- [10, 20] : 0 невозможно. Потому что мы пытаемся приписать начало
-- к списку 0, но 0 это не список.

-- для String = [Char]
-- 'x' : "abc" приписываем x в начало списка ['a', 'b', 'c'] = "abc"

-- примеры функций по работе со списками
-- длина списка
len1 :: [Int] -> Int
len1 [] = 0
len1 (head:tail) = 1 + len1 tail
-- len1 [10, 20, 30]: head = 10, tail = [20, 30]
-- len1 [10, 20, 30] -> 1 + len1 [20, 30] -> 1 + (1 + len1 [30]) -> ...
--   1 + (1 + 1 + (len1 [])) -> 1 + 1 + 1 + 0 = 3

-- функция, которая возвращает первый элемент списка:
head1 :: [Int] -> Int
head1 (head:tail) = head
-- замечание. Мы часто не пользуемся head или tail, тогда лучше заменять
-- переменные на _
-- head1 (head:_) = head -- лучше так

-- еще один пример работы со списком. Удваивание элементов.
-- "abc" -> "aabbcc"
doubleList :: String -> String -- [Char] -> [Char]
doubleList [] = []
-- для "xyz"   c='x', t = "yz"
doubleList (c:t) = c : c : doubleList t

-- приписать элемент в конец списка, начну писать сам за вас
push1 :: Int -> [Int] -> [Int] -- что приписать, в какой список
push1 a [] = [a] -- это приписывание в конец пустого списка
--push1 a (x:t) = ...  додумайте

-- Хвостовая рекурсия
-- функции с хвостовой рекурсией оптимизируются в цикл.
-- если можно не очень сложно написать код с хвостовой рекурсией,
-- лучше написать с ней

-- факториал с хвостовой рекурсией
factTail :: Integer -> Integer -> Integer
factTail 0 res = res
factTail 1 res = res -- можно обойтись без этого правила
factTail n res = factTail (n - 1) (res * n)

-- чтобы посчитать fact 4, нужно вызвать factTail 4 1.
-- Здесь смысл второй единички - это аргумент аккумулятор, в нем
-- копится ответ.
-- Как получается ответ:
-- factTail 4 1 = factTail 3 (1 * 4) = factTail 2 (1 * 4 * 3) = ...
--   = factTail 1 (1 * 4 * 3 * 2) = **правило 2** = 1 * 4 * 3 * 2 = 24

-- надо сделать удобный вызов

fact2 :: Integer -> Integer
fact2 n = factTail n 1

-- Хвостовая рекурсия для длины списка
lenTail :: [Int] -> Int -> Int
lenTail [] res = res
lenTail (x:t) res = lenTail t (res + 1)

len2 :: [Int] -> Int
len2 l = lenTail l 0 

-- len2 [10,20,30] = lenTail [10, 20, 30] 0 = lenTail [20, 30] 1 = 
--   = lenTail [30] 2 = lenTail [] 3 = 3

-- операторы let и where
len3 :: [Int] -> Int
len3 l = let lenTail [] res = res
             lenTail (x:t) res = lenTail t (res + 1)
 in lenTail l 0 
-- т.е. let вводит как бы "локальную переменную", ей можно пользоваться
-- после in. Это не совсем переменная, потому что ей невозможно внутри
-- in присвоить другое значение.

-- Другой пример, выражения
-- let x = 10 in x + 1
ff :: Double -> Double
ff x = let y = x^2 in y + 1 / y

gg :: Double -> Double
gg x = let y = x ^ 2 -- вместо двух строк можно разделить ;
           z = x ^ 3
        in 2*y + z + x

len4 :: [Int] -> Int
len4 l = lenTail l 0 where
          lenTail [] res = res
          lenTail (x:t) res = lenTail t (res + 1)

fff :: Int -> Int
fff x = a + b + c where
                   a = x + 1
                   b = x - 1
                   c = 0
                  
--- инфиксная и префиксная запись функций и операторов
fun :: Int -> Int -> Int
fun x y = x * y + 1

-- вызов
-- fun 10 20 - префиксный вызов
-- 10 `fun` 20 - инфиксный вызов (обратные кавычки)
-- 10 + 20 - инфиксный
-- (+) 10 20 - префиксный вызов
-- функции с обычными именами из символов вызываются по умолчанию
-- префиксно. Но если имя состоит из небуквенно-числовых символов,
-- то по умолчанию она вызывается инфиксно
-- давайте введем сами инфиксную функцию

(<=$) :: Int -> Int -> Int
x <=$ y = x - y - 1

-- используем 2 <=$ 1
-- или (<=$) 2 1 

-- Например, есть много встроеннных фунций из небуквенных символов,
-- ++ соединение двух списков (cons1)

-- Вообще, операции со списками.
-- https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html

-- Параметрический полиморфизм

-- Сделаем длину списка полиморфной, т.е. работающей со списками
-- разных типов.

len5 :: [a] -> Int
len5 l = lenTail l 0 where
          lenTail [] res = res
          lenTail (x:t) res = lenTail t (res + 1)
          
head2 :: [a] -> a -- типовая переменная с маленькой буквы. Типы с большой
head2 (h:_) = h

ggg :: a -> b -> a
ggg x _ = x

--- еще один способ задания функций:
plus1 :: Int -> Int
plus1 = \x -> x + 1
---
--- 100% эквивалентно: plus1 x = x + 1
--- но можно использовать в выражениях:
--- (\x -> x + 1) 3 
--- (\x -> x ++ [100]) [1, 2, 3]
--- (\(h:t) -> t ++ [h]) [10, 20, 30] можно сопоставлять с образцом

--- А если два аргумента
--- (\x y -> x + y) 5 6

--- еще немного о сопоставлении с образцом. Оператор cases
--fact :: Integer -> Integer
--fact 0 = 1
--fact 1 = 1  -- лишняя строка
--fact n = n * fact (n - 1)

fact5 :: Integer -> Integer
fact5 x = case x of
            0 -> 1
            1 -> 1
            n -> n * fact5 (n - 1)
            
-- полностью эквивалентно предыдущему
-- но в лямбда выражениях может пригодиться
abs10 = let abs = \x -> case x of
                         x | x > 0 -> x
                           | otherwise -> -x
          in abs 10
          
--- списки из чисел
--- [10, 20, 30, 40] - как раньше
--- [1..10] от 1 до 10 включительно
--- len2 [1..10]
--- [1, 3 .. 10] -- от 1 до 10 с шагом 2. Начинается как 1, 3 и т.д.
--- [1..] -- можно делать бесконечные списки
--- length [1..] зависнет, потому что не досчитать до бесконечности
--- [2,4..] все четные числа
--- take 10 [2, 4 ..] работает и возвращает первые 10 элементов

--- Функции высших порядков. Это функции, которые принимают фунции
--- в качестве аргументов

double :: (a -> a) -> a -> a
double f x = f (f x)
--- *Main> double (\x -> x + 1) 10
--- 12
--- double (\x -> x * 2) 10
--- 40
--- double (\x -> x ++ [100500]) [10, 20, 30]
--- [10,20,30,100500,100500]

--- Функция map. Применяет указанную ф-ию ко всем элементам списка
--- map (\x -> x + 1) [10, 20, 30] получится [11, 21, 31]
--- map (\x -> show x) [10, 20, 30]
--- ["10","20","30"]
--- map show [10, 20, 30]
--- ["10","20","30"]

--- Еще есть filter, оставлет в списке только те элементы, которые
--- подходят под условие
--- filter (\x -> mod x 2 == 0) [11, 20, 33, 55, 40]
--- остаются только [20, 40]

--- Сами сделаем map, filter - задачи
map1 :: (a -> b) -> [a] -> [b]
map1 _ [] = [] -- или map1 f [] = []
map1 f (h:t) = (f h) : (map1 f t)

-- с хвостовой рекурсией
map2 :: (a -> b) -> [a] -> [b]
map2 f l = reverse (helper l []) where
                                  helper [] r = r
                                  helper (h:t) r = helper t ((f h) : r)
--- helper [x, y, z] []
--- helper [y, z] [f(x)]
--- helper [z] [f(y), f(x)]
--- helper [] [f(z), f(y), f(x)]


--- filter


main :: IO ()
main = print (f (g 10))
