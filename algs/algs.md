# Алгоритмы для реализации

Курс на [repl.it](https://repl.it/data/classrooms/share/9a361fad6356e308ceee03c12f926f64)
В задачах на этом сайте ожидается, что входные данные приходят
из стандартного ввода, а выводиться должны в стандартный вывод.
Это позволяет проверить правильность программы автоматически на
сайте.

Если у задачи есть дополнительные тесты,
они распространяются в виде набора
файлов с расширениями, соответственно, `in` и `out`. Для
проверки решения необходимо запускать программу следующим
образом:

`program.exe <test.in >program.out`

Для проверки правильности ответа:

`diff program.out test.out`

Это сравнит вывод программы и правильный ответ.

Либо вы можете пользоваться возможностями среды
разработки, чтобы она при отладочном запуске программы
перенаправляла стандартный ввод и вывод.

## Алгоритмы на графах

### Алгоритм Краскала
Описание в [Викиконспекты ИТМО](https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9A%D1%80%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D0%B0)

Реализуйте алгоритм Краскала, учтите следующее:
1. Для хранения графа используйте структуру данных "ребро",
она должна хранить номера своих вершин и свой вес.
1. Храните для каждой вершины список ребер, которые
с ней связаны.
1. Для проверки того, что ребро
соединяет две разных компоненты связанности, используйте
наивную реализацию: в ней нужно хранить компоненты связности
как множества (set) вершин. При объединении компонент
связности нужно объединять множества.
1. После того, как решите следующую задачу, замените
наивную реализацию на реализацию через лес непересекующихся
множеств.   

Пример входных данных. Граф задан как последовательность
чисел. Сначала даны два числа - количество
вершин `v` и количество ребер графа `e`. После этого
даны `e` троек чисел с описанием ребер. Это два числа
с номерами вершин (нумерация с нуля) и вес ребра.

Пример входных данных
```
3 3
0 1 10
1 2 20
0 2 30
```

В выводе необходимо указать сначала количество ребер в ответе,
потом суммарный вес ребер и дальше необходимо перечислить
ребра в порядке, в котором их добавлял алгоритм Краскала.
При выводе ребра напишите два числа - номер меньшей,
а потом номер большей вершины.

Для указанного ввода ответом будет:
```
2 30
0 1
1 2
```

### Структура данных: система непересекающихся множеств
Описание в [Викиконспекты ИТМО](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%9D%D0%9C_(%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D0%BB%D0%B5%D1%81%D0%B0_%D0%BA%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D1%8B%D1%85_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D0%B5%D0%B2))

[Набор тестов](union-find forest/tests.zip)

*Входные данные*. Сначала дается `n` - количество элементов
множества. Далее даётся `n-1` пара чисел. Каждое число
пары означает номер элемента (с нуля), для которого 
надо найти множество. Два множества нужно объединить.
После каждой пары множеств нужно вывести, верно ли,
что элемент 0 и элемент `n-1` содержатся в одном множестве:
`YES` или `NO`:

Пример ввода:
```
4
0 1
2 3
1 2
``` 

Пример вывода:
```
NO
NO
YES
```