# Объектно-ориентированное программирование

Объектно-ориентированное программирование (ООП) — это «парадигма»
программирования, т.е. подход к тому, из каких базовых
компонентов и на основе каких принципов составлять программу.
В ООП программа состоит из взаимодействующих друг с
другом объектов. Большинство современных и популярных
языков программирования поддерживают ООП. Это верно и для
Java с Python. Более того, Java неотделима от ООП, вы уже сами видели, что
даже минимальная Java программа требует введения класса, и запускать в Java
необходимо именно класс. Класс — одно из базовых понятий ООП в Java.

Для сравнения, функциональная парадигма программирования предполагает, что
программу нужно составлять из функций, которые вызывают друг друга и возвращают
неизменяемые значения. Я рекомендую для общего развития попробовать изучить
язык Haskell, чтобы увидеть функциональное программирование в действии. Если вы
не делали это раньше, то он расширит ваше сознание и поменяет восприятие
реальности.

Мы же продолжим обсуждать ООП. Я не буду сейчас отдельно обсуждать принципы ООП и
его теоретические основы, хотя это принято делать вначале. Предлагаю
сразу перейти к практике. Когда практики будет достаточно, мы сможем обобщить
наши знания и ввести все необходимые понятия и принципы, как правильно
писать программы объектно-ориентированно.

Мы не изучали ООП в Python во время курса по Python, но вы сможете
изучить эту тему самостоятельно. В этом вам поможет знание ООП из Java.
В двух языках они устроены похоже, и я буду иногда для пояснения
некоторых особенностей сравнивать ООП в Java и Python. 

## Класс и объект

Начнем с практической задачи. Представим, что мы хотим хранить в одной
переменной сразу много разной информации. Например, если в нашей программе
нужно хранить информацию о студентах, давайте опишем новый тип данных, который
позволит хранить сразу и имя студента, и его возраст, и курс, на котором он учится:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.
}
```

На что обратить внимание
1. Мы будем всегда создавать классы в отдельных файлах. Один класс = один файл.
На самом деле, в Java это не обязательно, но для того, чтобы писать несколько
классов в одном файле, нужны веские основания. Нам это не потребуется. Единственное
исключение, анонимные классы, которые мы изучим сильно позже,
для них отдельный файл не создается.

    Для перемещения между классами можно использовать сочетание клавиш `Ctrl + N`,
    после этого достаточно написать начало имени класса, чтобы к нему перейти.
1. Имя класса — всегда с большой буквы. Это важно. С большой буквы в Java пишутся
только классы и интерфейсы.
1. Имя файла должно совпадать с именем класса внутри. Поэтому лишний раз
напоминаю, что любые переименовывания нужно делать в IDEA с помощью рефакторинга.
Конкретно переименовывание делается с помощью сочетания `Shift + F6`.
Иначе, если вы будете
самостоятельно переименовывать класс, то потом будете разбираться, как переименовать
отдельно файл с классом.

Внутри класса Student заведено три **поля**. В полях хранятся данные. Поля заводятся
как переменные, сначала указывается тип, потом имя.

Как же теперь использовать новый тип данных? Создадим класс для запуска
наших экспериментов:

```java
public class ExperimentsWithStudents {
    public static void main(String[] args) {
        // Здесь будем писать наши эксперименты, см. код ниже 
    }
}
```

Для начала введем несколько переменных для хранения студентов:

```
Student s1 = new Student();
Student s2 = new Student();
Student s3 = s1; 
```

В этом коде операция `new Student()` создает нового
студента, в памяти выделяется область для хранения
имени и двух чисел — года рождения и года
обучения. Конструкция `Student s1` вводит новую
переменную, указывая, что в ней будут храниться студенты.
В конце для примера заведена еще одна переменна `s3`,
для нее нового студента не создается, она хранит ссылку
на того же студента, который был создан для переменной
`s1`. См. картинку:

<img src="objects-in-memory.svg" width="400px" alt="objects-in-memory">

**Класс** `Student` описывает, как устроена информация о студентах.
А сами студенты должны создаваться отдельно оператором `new`.
Конкретные воплощения класса называются **объектами**. В
нашем примере создано ровно два объекта. В Java оператор `new` это
основной метод создания объекта. Чтобы появился объект, нужно прямо или
косвенно вызвать этот оператор.

Мы обсудили два основных понятия ООП в Java: класс и объект. Чтобы еще раз
закрепить понимание, скажем, что класс описывает объекты, а объекты – это
воплощения класса. В программе всегда ровно 1 класс, и произвольное количество
объектов, оно зависит от того, сколько объектов было создано во время работы
программы. Т.е. сколько раз во время работы программы был вызван оператор `new`.

## Обращение к полям класса

Как теперь пользоваться полями, т.е. записывать в них значения и читать их.
Продолжим наш код:

```
s1.name = "Ilya";
s1.yearOfBirth = 1910;
s1.yearOfStudy = 1;

s2.name = "Olya";
s2.yearOfBirth = 1912;
s2.yearOfStudy = 2;

System.out.println("Имя первого студента: " + s1.name);
``` 

Здесь видно, что для обращения к полю нужно написать `ОБЪЕКТ.ИМЯ_ПОЛЯ`.
Мы не можем писать только имя поля, например, `name`, потому что будет неясно,
чье это имя. У нас же два студента. Поэтому явно пишем в начале, у какого объекта
нам требуется поле.

## Методы

В классе могут быть методы. Если поля хранят данные, то методы производят вычисления.
Давайте введем метод `sayHello`, который будет заставлять студента здороваться. 
Синтаксис описания метода полностью соответствует синтаксису написания того,
что мы раньше называли фунциями, только сейчас мы уберем все служебные слова
типа `private`, `static`, `public`, которые писали раньше. Будем добавлять эти
слова позже, объясняя, наконец, что они значат.

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.

    void sayHello() {
        System.out.println(
                "Добрый вечер, меня зовут " +
                this.name +  // про this читайте ниже
                ", я учусь на " +
                this.yearOfStudy + 
                " курсе."
        );
    }
}
```

Для проверки работы метода продолжим наш код внутри класса `ExperimentsWithStudents`.
Попросим каждого из студентов поздороваться:

```
s1.sayHello();
s2.sayHello();
s3.sayHello();
```

Вывод:

```
Добрый вечер, меня зовут Ilya, я учусь на 1 курсе.
Добрый вечер, меня зовут Olya, я учусь на 2 курсе.
Добрый вечер, меня зовут Ilya, я учусь на 1 курсе.
```

Почему разные вызовы `sayHello()` выдали разный результат?
Внутри метода `sayHello()` используется выражение
`this.name`. Это обращение к полю `name` объекта `this`. Объект
`this` означает **тот объект, для которого вызван метод**. При первом
вызове `s1.sayHello()` переменной `this` присваивается объект
из переменной `s1`. При вызове `s2.sayHello()` переменной
`this` присваивается объект из `s2`.

Кстати, переменную `this` в Java можно не указывать. Поэтому
метод `sayHello()` может быть переписан:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.

    void sayHello() {
        System.out.println(
                "Добрый вечер, меня зовут " +
                name +  // this подразумевается
                ", я учусь на " +
                yearOfStudy + 
                " курсе."
        );
    }
}
```

В этом примере `name` может относиться только к полю `name`, поэтому можно
не писать полностью `this.name`. Моя рекомендация, не писать `this`,
если оно не нужно.  

В Python вместо `this` пишут `self`. В отличие от Java, сокращать `self` нельзя.

Для примера напишем еще один метод, чтобы вспомнить, как оформлять методы.
Допустим, сделаем метод проверки, совершеннолетний ли студент. Вставим это в
класс `Student`:

```
boolean isAdult() {
    return 2020 - yearOfBirth >= 18;
}
```

Можем воспользоваться этим методом в классе `ExperimentsWithStudents`:

```
if (s1.isAdult())
    System.out.println("студент " + s1.name + " совершеннолетний");
```

Здесь вы можете взять код, который получился к этому
моменту: [Student.java](first-version/Student.java) и
[ExperimentsWithStudents.java](first-version/ExperimentsWithStudents.java). 

## Конструкторы

Давайте вспомним, какой код был у нас написан, чтобы создать и заполнить данными
одного студента:

```
Student s1 = new Student();

s1.name = "Ilya";
s1.yearOfBirth = 1910;
s1.yearOfStudy = 1;
``` 

Этот код слишком длинный, и его нужно повторять, если необходимо создать несколько
студентов. Код можно сократить, если воспользоваться
**конструктором**. Конструктор — это метод, который вызывается каждый раз при
создании объекта. Оператор `new`, на самом деле, не только выделяет память для
хранения полей объекта, но и вызывает конструктор.

Пока что в нашем классе `Student`
не написан конструктор, но это не значит, что его нет. В классе `Student`
сейчас есть пустой **конструктор по-умолчанию**, который ничего не делает. Давайте
добавим полезный конструктор, который позволит создавать студента следующим
образом:  

```
Student s1 = new Student("Ilya", 1910, 1);
```

Чтобы этот код заработал, нужно описать конструктор:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.
    
    //вот он, это конструктор
    Student(String name, int yearOfBirth, int yearOfStudy) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.yearOfStudy = yearOfStudy;
    }
    
    // здесь пропущены методы класса
}
```

Конструктор описывается как метод, только у него нет возвращаемого типа, и имя
метода совпадает с именем класса. В этом примере конструктор получает на вход
аргументы: имя, год рождения. Задача конструктора присвоить эти значения полям.
Здесь приходится явно разделять `this.name` и `name`. Первое — это поле класса,
второе — это аргумент функции. Здесь внутри конструктора видна ситуация, когда
сокращать слово `this` нельзя. Иначе `name` уже не будет означать поле.

Добавленный конструктор портит код, который был раньше. Больше не работает
выражение `new Student()`, потому что оно подразумевает вызов конструктора без
аргументов. Чтобы код работал как раньше, нужно добавить конструктор без
аргументов явно. Заодно давайте добавим в конструкторы печать приветствия
при создании объекта:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.
    
    // новый конструктор без аргументов
    Student() {
        System.out.println("Меня создали");
    }

    Student(String name, int yearOfBirth, int yearOfStudy) {
        System.out.println("Меня создали");
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.yearOfStudy = yearOfStudy;
    }
    
    // здесь пропущены методы класса
} 
```

Для проверки добавим в `ExperimentsWithStudents`:

```
Student s4 = new Student();
Student s5 = new Student("John", 1921, 3); 
``` 

Оба способа создания объекта работают, оба печатают фразу "Меня создали", во втором
случае поля сразу заполняются указанными значениями.

Смысл конструктора в том, что он производит инициализацию объекта, подготавливает
его к использованию. При использовании объекта вы всегда можете быть уверены,
что для него был вызван конструктор.

Конструктор, который мы написали, и который
нужен только для копирования переданных значений в поля, это самый
распространенный вид конструкторов. В большинстве случаев они бывают именно
такими: получают значения и записывают их в поля.
Необходимость писать подобные конструкторы — это очередная особенность
Java, которая удлиняет код.

## Инициализация полей

Какие значения имеют поля до того, как им что-то присваивается? Если вызвать
конструктор `new Student()`, для полей нового объекта не будет выполнено
явного присваивания. Тем не менее, можем попробовать узнать, что там записано:
```
Student s6 = new Student();
System.out.println(s6.name);         // null
System.out.println(s6.yearOfBirth);  // 0
System.out.println(s6.yearOfStudy);  // 0
``` 
 В этом случае поля имеют значения по-умолчанию: 0 для int,
null для String. Эти значения аналогичны значениям, которыми заполняется новый
только что созданный массив. Напомню, что `new int[10]` заполняется нулями, а 
`new String[10]` заполняется `null`.

 В классе можно инициализировать значения полей, присваивая им значения сразу
 при определении:
 
 ```java
 public class Student {
     String name = "без имени";
     int yearOfBirth;
     int yearOfStudy = 1;
     
     // здесь пропущены методы и конструкторы класса
 } 
 ```

Теперь код, который мы писали раньше, выдаст другие результаты:  

```
Student s6 = new Student();
System.out.println(s6.name);         // "без имени"
System.out.println(s6.yearOfBirth);  // 0, потому что не присвоено другого
System.out.println(s6.yearOfStudy);  // 1
``` 

Конечно, вызов второго из определенным нами конструкторов уже не оставит
исходных значений: 

```
Student s7 = new Student("ИМЯ", 2000, 5);
System.out.println(s7.name);         // "ИМЯ"
System.out.println(s7.yearOfBirth);  // 2000
System.out.println(s7.yearOfStudy);  // 5
``` 

**Инициализация полей выполняется до вызова конструктора**. Т.е. при создании
объекта у него сначала полям присваиваются значения из инициализаторов, и только
потом вызывается конструктор, который, возможно, перезапишет эти значения
другими.

Вот окончательная версия созданных нами классов:
[Student.java](with-constructors/Student.java) и
[ExperimentsWithStudents.java](with-constructors/ExperimentsWithStudents.java).

Мы больше не будем изменять эти классы. Все следующие
разделы создадут для примеров новые классы.

## Ключевое слово `final`

У слова `final` много применений, мы рассмотрим применения с локальными
переменными и полями класса. 

Слово `final` при определении локальных
переменных и полей класса означает, что значение нельзя изменять после первого
присваивания.
Другими словами слово `final` используется для определения констант.
Например, можно ввести
константу `pi = 3.1415926`, и никакого смысла присваивать другое значение для
$\pi$ нет, наоборот, нужно защитить программиста от случайного переприсваивания
значения.

С локальной переменной внутри метода это работает следующим образом:

```
final int x = 10;
x = 42;  // нельзя!

final int y; // можно не присваивать сразу
y = 10; // первое присваивание
y = 11; // нельзя! это уже второе присваивание

final int z;
if (...)
    z = 10; // это первое присваивание
else
    z = 20; // или это
z = 30; // нельзя! это точно второе присваивание.
```

Ключевое слово `final` можно написать при определении поля, его смысл
полностью соответствует смыслу финальной локальной переменной, но
правила немного более сложные из-за того, что значения полям можно присваивать
в разных местах.

Например, `final int x` означает, что полю `x` необходимо присвоить значение
один раз,
в инициализаторе или конструкторе, и после этого значение изменять нельзя.
Посмотрим это на синтетическом примере:

```java
public class A {
    final int x = 42;
    final int y;
    final int z;

    A() {
        x = 123; // нельзя, потому что значение уже есть
        y = 1; // надо обязательно что-то присвоить, т.к. нет инициализатора
    
        // можно выбрать, что присвоить, но присвоить все равно
        // нужно только один раз
        if (x > 0)
            z = 5;
        else
            z = -5;
    }

    // другой конструктор. Объект будет создан либо с помощью
    // этого конструктора, либо предыдущего
    A(int y) {
        this.y = y;
        z = -5; // в этом конструкторе тоже надо что-то присвоить для z
    }   

    // какой-то метод
    void f() {
        z = 123; //нельзя, потому что после создания объекта
                 //значение уже присвоено, его нельзя менять
    }   
}
```

## Модификаторы доступа

Мы уже умеем описывать внутри класса поля, методы и конструкторы.
Будем называть всё это элементами класса. Так вот, у каждого
элемента класса есть модификатор доступа, который описывает,
откуда можно обращаться к этому элементу класса. Есть ровно
четыре модификатора:

* `public` — публичный, означает, что этот элемент доступен из
любого другого класса, т.е. из любого другого места программы.
* `private` — приватный, означает, что элемент доступен только
из того же самого класса. Фактически, только из того же файла.
* пустой, когда ничего не пишется. Он означает пакетную видимость,
т.е. когда элемент доступен только из того же пакета (каталога),
где он определен.
* `protected` означает пакетную видимость и видимость для
потомков, см. будущие лекции про наследование.

Как видите, все элементы класса
`Student` в предыдущих примерах 
имели пакетную видимость, потому что мы использовали
пустой модификатор.

Давайте определим новый класс, он будет называться `Person`, это модифицированная
версия класса `Student`. Укажем еще везде модификаторы доступа.

```java
public class Person {
    private String name;
    private int yearOfBirth;

    public Person(String name, int yearOfBirth) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
    }

    // метод вычисления возраста
    public int getAge() {
        return 2020 - yearOfBirth;
    }

    // метод, чтобы поздороваться
    public void sayHello() {
        System.out.printf(
                "Здравствуйте, меня зовут %s, мне %d лет.\n",
                name,
                getAge()
        );
    }
}

```

И класс для запуска примера:

```java
public class ExperimentsWithPersons {

    public static void main(String[] args) {
        Person p = new Person("Илья", 1910);
        p.sayHello(); //Выводит: Здравствуйте, меня зовут Илья, мне 110 лет.
    }
}
```


Больше мы так делать не будем, с этого момента договоримся
о некоторых принципах выбора модификаторов доступа:

1. 

## get- и set- методы (геттеры и сеттеры)

## Статические элементы класса

## Порядок элементов в классе
