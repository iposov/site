# Объектно-ориентированное программирование

Объектно-ориентированное программирование (ООП) — это «парадигма»
программирования, т.е. подход к тому, из каких базовых
компонентов и на основе каких принципов составлять программу.
В ООП программа состоит из взаимодействующих друг с
другом объектов. Большинство современных и популярных
языков программирования поддерживают ООП. Это верно и для
Java с Python. Более того, Java неотделима от ООП, вы уже сами видели, что
даже минимальная Java программа требует введения класса, и запускать в Java
необходимо именно класс. Класс — одно из базовых понятий ООП в Java.

Для сравнения, функциональная парадигма программирования предполагает, что
программу нужно составлять из функций, которые вызывают друг друга и возвращают
неизменяемые значения. Я рекомендую для общего развития попробовать изучить
язык Haskell, чтобы увидеть функциональное программирование в действии. Если вы
не делали это раньше, то он расширит ваше сознание и поменяет восприятие
реальности.

Мы же продолжим обсуждать ООП. Я не буду сейчас отдельно обсуждать принципы ООП и
его теоретические основы, хотя это принято делать вначале. Предлагаю
сразу перейти к практике. Когда практики будет достаточно, мы сможем обобщить
наши знания и ввести все необходимые понятия и принципы, как правильно
писать программы объектно-ориентированно.

Мы не изучали ООП в Python во время курса по Python, но вы сможете
изучить эту тему самостоятельно. В этом вам поможет знание ООП из Java.
В двух языках они устроены похоже, и я буду иногда для пояснения
некоторых особенностей сравнивать ООП в Java и Python. 

## Класс и объект

Начнем с практической задачи. Представим, что мы хотим хранить в одной
переменной сразу много разной информации. Например, если в нашей программе
нужно хранить информацию о студентах, давайте опишем новый тип данных, который
позволит хранить сразу и имя студента, и его возраст, и курс, на котором он учится:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.
}
```

На что обратить внимание
1. Мы будем всегда создавать классы в отдельных файлах. Один класс = один файл.
На самом деле, в Java это не обязательно, но для того, чтобы писать несколько
классов в одном файле, нужны веские основания. Нам это не потребуется. Единственное
исключение, анонимные классы, которые мы изучим сильно позже,
для них отдельный файл не создается.

    Для перемещения между классами можно использовать сочетание клавиш `Ctrl + N`,
    после этого достаточно написать начало имени класса, чтобы к нему перейти.
1. Имя класса — всегда с большой буквы. Это важно. С большой буквы в Java пишутся
только классы и интерфейсы.
1. Имя файла должно совпадать с именем класса внутри. Поэтому лишний раз
напоминаю, что любые переименовывания нужно делать в IDEA с помощью рефакторинга.
Конкретно переименовывание делается с помощью сочетания `Shift + F6`.
Иначе, если вы будете
самостоятельно переименовывать класс, то потом будете разбираться, как переименовать
отдельно файл с классом.

Внутри класса Student заведено три **поля**. В полях хранятся данные. Поля заводятся
как переменные, сначала указывается тип, потом имя.

Как же теперь использовать новый тип данных? Создадим класс для запуска
наших экспериментов:

```java
public class ExperimentsWithStudents {
    public static void main(String[] args) {
        // Здесь будем писать наши эксперименты, см. код ниже 
    }
}
```

Для начала введем несколько переменных для хранения студентов:

```
Student s1 = new Student();
Student s2 = new Student();
Student s3 = s1; 
```

В этом коде операция `new Student()` создает нового
студента, в памяти выделяется область для хранения
имени и двух чисел — года рождения и года
обучения. Конструкция `Student s1` вводит новую
переменную, указывая, что в ней будут храниться студенты.
В конце для примера заведена еще одна переменна `s3`,
для нее нового студента не создается, она хранит ссылку
на того же студента, который был создан для переменной
`s1`. См. картинку:

<img src="objects-in-memory.svg" width="400px" alt="objects-in-memory">

**Класс** `Student` описывает, как устроена информация о студентах.
А сами студенты должны создаваться отдельно оператором `new`.
Конкретные воплощения класса называются **объектами**. В
нашем примере создано ровно два объекта. В Java оператор `new` это
основной метод создания объекта. Чтобы появился объект, нужно прямо или
косвенно вызвать этот оператор.

Мы обсудили два основных понятия ООП в Java: класс и объект. Чтобы еще раз
закрепить понимание, скажем, что класс описывает объекты, а объекты – это
воплощения класса. В программе всегда ровно 1 класс, и произвольное количество
объектов, оно зависит от того, сколько объектов было создано во время работы
программы. Т.е. сколько раз во время работы программы был вызван оператор `new`.

## Обращение к полям класса

Как теперь пользоваться полями, т.е. записывать в них значения и читать их.
Продолжим наш код:

```
s1.name = "Ilya";
s1.yearOfBirth = 1910;
s1.yearOfStudy = 1;

s2.name = "Olya";
s2.yearOfBirth = 1912;
s2.yearOfStudy = 2;

System.out.println("Имя первого студента: " + s1.name);
``` 

Здесь видно, что для обращения к полю нужно написать `ОБЪЕКТ.ИМЯ_ПОЛЯ`.
Мы не можем писать только имя поля, например, `name`, потому что будет неясно,
чье это имя. У нас же два студента. Поэтому явно пишем в начале, у какого объекта
нам требуется поле.

## Методы

В классе могут быть методы. Если поля хранят данные, то методы производят вычисления.
Давайте введем метод `sayHello`, который будет заставлять студента здороваться. 
Синтаксис описания метода полностью соответствует синтаксису написания того,
что мы раньше называли фунциями, только сейчас мы уберем все служебные слова
типа `private`, `static`, `public`, которые писали раньше. Будем добавлять эти
слова позже, объясняя, наконец, что они значат.

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.

    void sayHello() {
        System.out.println(
                "Добрый вечер, меня зовут " +
                this.name +  // про this читайте ниже
                ", я учусь на " +
                this.yearOfStudy + 
                " курсе."
        );
    }
}
```

Для проверки работы метода продолжим наш код внутри класса `ExperimentsWithStudents`.
Попросим каждого из студентов поздороваться:

```
s1.sayHello();
s2.sayHello();
s3.sayHello();
```

Вывод:

```
Добрый вечер, меня зовут Ilya, я учусь на 1 курсе.
Добрый вечер, меня зовут Olya, я учусь на 2 курсе.
Добрый вечер, меня зовут Ilya, я учусь на 1 курсе.
```

Почему разные вызовы `sayHello()` выдали разный результат?
Внутри метода `sayHello()` используется выражение
`this.name`. Это обращение к полю `name` объекта `this`. Объект
`this` означает **тот объект, для которого вызван метод**. При первом
вызове `s1.sayHello()` переменной `this` присваивается объект
из переменной `s1`. При вызове `s2.sayHello()` переменной
`this` присваивается объект из `s2`.

Кстати, переменную `this` в Java можно не указывать. Поэтому
метод `sayHello()` может быть переписан:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.

    void sayHello() {
        System.out.println(
                "Добрый вечер, меня зовут " +
                name +  // this подразумевается
                ", я учусь на " +
                yearOfStudy + 
                " курсе."
        );
    }
}
```

В этом примере `name` может относиться только к полю `name`, поэтому можно
не писать полностью `this.name`. Моя рекомендация, не писать `this`,
если оно не нужно.  

В Python вместо `this` пишут `self`. В отличие от Java, сокращать `self` нельзя.

Для примера напишем еще один метод, чтобы вспомнить, как оформлять методы.
Допустим, сделаем метод проверки, совершеннолетний ли студент. Вставим это в
класс `Student`:

```
boolean isAdult() {
    return 2020 - yearOfBirth >= 18;
}
```

Можем воспользоваться этим методом в классе `ExperimentsWithStudents`:

```
if (s1.isAdult())
    System.out.println("студент " + s1.name + " совершеннолетний");
```

Здесь вы можете взять код, который получился к этому
моменту: [Student.java](Student.java) и
[ExperimentsWithStudents.java](ExperimentsWithStudents.java). 

## Конструкторы

Давайте вспомним, какой код был у нас написан, чтобы создать и заполнить данными
одного студента:

```
Student s1 = new Student();

s1.name = "Ilya";
s1.yearOfBirth = 1910;
s1.yearOfStudy = 1;
``` 

Этот код слишком длинный, и его нужно повторять, если необходимо создать несколько
студентов. Код можно сократить, если воспользоваться
**конструктором**. Конструктор — это метод, который вызывается каждый раз при
создании объекта. Оператор `new`, на самом деле, не только выделяет память для
хранения полей объекта, но и вызывает конструктор.

Пока что в нашем классе `Student`
не написан конструктор, но это не значит, что его нет. В классе `Student`
сейчас есть пустой **конструктор по-умолчанию**, который ничего не делает. Давайте
добавим полезный конструктор, который позволит создавать студента следующим
образом:  

```
Student s1 = new Student("Ilya", 1910, 1);
```

Чтобы этот код заработал, нужно описать конструктор:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.
    
    //вот он, это конструктор
    Student(String name, int yearOfBirth, int yearOfStudy) {
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.yearOfStudy = yearOfStudy;
    }
    
    // здесь пропущены методы класса
}
```

Конструктор описывается как метод, только у него нет возврщаемого типа, и имя
метода совпадает с именем класса. В этом примере конструктор получает на вход
аргументы: имя, год рождения. Задача конструктора присвоить эти значения полям.
Здесь приходится явно разделять `this.name` и `name`. Первое — это поле класса,
второе — это аргумент функции. Здесь внутри конструктора видна ситуация, когда
сокращать слово `this` нельзя. Иначе `name` уже не будет означать поле.

Добавленный конструктор портит код, который был раньше. Больше не работает
выражение `new Student()`, потому что оно подразумевает вызов конструктора без
аргументов. Чтобы код работал как раньше, нужно добавить конструктор без
аргументов явно. Заодно давайте добавим в конструкторы печать приветствия
при создании объекта:

```java
public class Student {
    String name;     //имя
    int yearOfBirth; //год рождения
    int yearOfStudy; //первый курс, второй, третий и т.п.
    
    Student() {
        System.out.println("Меня создали");
    }

    Student(String name, int yearOfBirth, int yearOfStudy) {
        System.out.println("Меня создали");
        this.name = name;
        this.yearOfBirth = yearOfBirth;
        this.yearOfStudy = yearOfStudy;
    }
    
    // здесь пропущены методы класса
} 
```

Для проверки добавим в `ExperimentsWithStudents`:

```
Student s4 = new Student();
Student s5 = new Student("John", 1921, 3); 
``` 

Оба способа создания объекта работают, оба печатают фразу "Меня создали", во втором
случае поля сразу заполняются указанными значениями.

Смысл конструктора в том, что он производит инициализацию объекта, подготавливает
его к использованию. При использовании объекта вы всегда можете быть уверены,
что для него был вызван конструктор. Конструктор, который мы написали, и который
нужен только для копирования переданных значений в поля, это один из
самых распространенных конструкторов, в большинстве случаев они бывают именно
такими.

Продолжение следует

