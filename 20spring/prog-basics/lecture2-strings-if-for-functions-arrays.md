# Работа со строками

Документация с полным списком возможностей [String](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html)

Действия со строками (как и с любыми другими объектами)
выполняются следующим синтаксисом:
1. `строка.действие(аргументы)`
2. `String.действие(аргументы)` (изредка бывает так)

```
String s = "abcdef";
sout(s.length());  // длина строки
sout(s.charAt(0)); //символ `a`, индексы с нуля. s[0]
sout(s.substring(2, 5)); //строка "cde", аналог s[2:5]
sout(s.substring(2)); //строка "cdef", аналог s[2:]
sout(s.startsWith("abc")); //true, "начинается с"
sout(s.endsWith("def")); //true
sout(s.repeat(2)); //аналог s * 2
sout(s.equals("abcdef")); // (!!!) сравнение строк
sout(s == "abcdef"); // (!!!) так нельзя
```

### Форматирование строки

Замена ``f"Меня зовут {name}, мне {age} лет." из python.

На java
```
"Меня зовут " + name + ", мне " + age + " лет."
```
Это может быть неудобно. Альтернатива:

```
String.format("Меня зовут %s, мне %d лет.", name, age).
```

В python аналогичная конструкция:

```python
"Меня зовут %s, мне %d лет.".format(name, age)
```

`%s` означает, что подставляется строка

`%d` означает, что подставляется число в десятичной с.сч

`%f` означает вещественное число

[Подробнее о форматах](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Formatter.html#syntax)

Там же вы узнаете, как, например, просить выводить ровно
две цифры после запятой: `%.2f`.


# Операторы управления потоком исполнения

## условный оператор if

см. [базовый синтаксис](basic-syntax.md)

## Цикл for

### Цикл for each
Java имеет цикл for, аналогичный python:
```
# python
for x in list:
    print(x)
```
Аналог:
```
for (x : list) { // можно не ставить {}, т.к. одно дейстие
    sout(x);
}
```
Пользуйтесь в первую очередь именно этой версией цикла
for. Она называется "for each".

### Классический for
Такой цикл пришел еще из языка `C`. Это продвинутая
версия перебора диапазона значений (ср. python
`for i in range(10)`).

Пример, самый частый вариант использования цикла:
```
for (int i = 0; i < 10; i++) { // можно без {}
    sout(i);
}
``` 
Это перебор чисел `i` от 0 до 9.

Схема работы
```
for (инициализатор ; условие ; итератор)
    тело
``` 

1. Выполняется инициализатор. В примере: создается
и инициализируется нулём переменная `i`. Кстати,
переменные, введенные в иницаилизаторе, доступны
только внутри цикла.
2. Проверяем условие. Если **неверно**, то закончить цикл.
   Можно считать, что в теле цикла условие выполнено.
3. Выполнить тело.
4. Выполнить итератор. В примере оператор `++` увеличит
на 1. Аналогично `i += 1`, `i = i + 1`.
5. Возвращаемся к шагу 2 проверки условия.

Еще пример:

```
String s = "abcdef";
for (int i = 0; i < s.length(); i++)
    sout(s.charAt(i));
```

Здесь `i` всегда меньше, чем длина строки, поэтому последнее
значение `i` это `s.length() - 1`.

В обратную сторону перебрать:

```
String s = "abcdef";
for (int i = s.length() - 1; i >= 0; i--)
    sout(s.charAt(i));
```

Последний пример, самый необычный, нужно только для
понимания работы `for`:

```
for (int i = 0, j = 10; i < j; i++, j--)
    sout(i + " " + j); 
```

Распечатает:
```
0 10
1 9
2 8
3 7
4 6
```

`5 5` уже не выведется, потому что для этих значений
не выполнено условие `i < j`.

### Оператор выбора switch:

Это версия оператора из времен C, она очень ограниченная
и неудобная. Поэтмоу пока вы редко будете использовать
такой оператор. Зато в будущих версиях java его возможности
значительно увеличатся.

```
String name = "Ilya";
switch (name) {
    case "Николай Валентинович":
        sout("Здравствуйте, " + name);
        break;
    case "Bill Gates":
    case "Elon Mask":
        sout("Hello, " + name);
        break;
    default:
        sout("Привет, " + name);
} 
```

Обязательно ставится `break`, чтобы закончить выполнение
`switch`, иначе выполнение идет дальше.

## Функции

см. [базовый синтаксис](basic-syntax.md)

## Массивы

В Python есть списки (`[10, 20, "abc]`), в Java их
аналогом являются тоже списки типа `List`.

В Java дополнительно есть массивы. Они позволяют хранить
набор значений одного типа, в отличие от списков

1. делают это очень эффективно в плане памяти;
2. позволяют хранить значения базовых типов: `int`, `char`
и т.п.
3. доступен только ограниченный набор операций, в частности
массивы имеют фиксированный размер, который не может
измениться после создания массива.

Пример создания и использования массива:

```
int[] a = new int[3];
a[0] = 42;
a[1] = 24;
a[2] = 100;
sout(a[0] + a[2]); // 142
sout(a); // так можно, но вы увидете не содержимое массива
sout(Arrays.toString(a));
```