# Растровые изображения

Будем рисовать с помощью Java изображения. Причем,
разберемся, как можно редактировать изображения попиксельно,
т.е. изменяя цвет каждого пикселя отдельно. Нас не будет интересовать ничего
кроме изменения отдельных пикселей, в частности, мы не будем обсуждать,
как рисовать линии, окружности, кривые и другие примитивы. Хотя в JavaFX можно
рисовать не хуже, чем мы рисовали на HTML Canvas на курсе компьютерной графики.

## Класс `Image`

Здесь и далее мы будем обсуждать классы только из пакетов javafx. Будьте
внимательны при импортировании класса, убедитесь, что вы **не** подключаете
классы из других пакетов. Например, подключайте `javafx.scene.image.Image`,
а не `java.awt.Image` и тем более не `com.sun.prism.Image`. Из `com.sun` вообще
никогда ничего не подключайте.

Класс `Image` хранит информацию о содержимом изображения и умеет загружать
изображения с диска или из Интернета. Посмотрите, какие конструкторы есть
у этого класса:
```
new Image()
```
Напомню, что вы можете поставить курсор внутрь скобок и нажать `Ctrl + P`,
тогда вы увидите, что можно указать для создания изображения. Это могут быть
такие параметры
* ссылка (URL) на изображение
* поток байт (`InputStream`) с изображением, например, можно указать
`FileInputStream` для чтения изображения из файла.
* загружать ли изображение в фоне. Т.е. оно будет загружаться, а ваша программа
продолжать работать. Вы сможете периодически обращаться к изображению, чтобы
узнать, загрузилась ли она, а если нет, была ли ошибка во время загрузки. 
* размер изображения. Вы можете загрузить изображение с неоригинальным размером.
Например, если у вас на диске фотография 5000 на 4000 пикселей, можно попросить
загрузить ее размером 500 на 400, это сэкономит память.
* сохранить ли соотношение сторон (preserve ration).
Если вы укажете в прошлом пункте размеры
1000 на 400, то картинка все равно загрузится как 500 на 400, чтобы не 
вытягиваться.
* сглаживать ли результат при изменении размера (smooth), без сглаживания
используется очень быстрый, но некрасивый алгоритм изменения размера.

## Отображаем `Image` на экране

Сам по себе `Image` на экране не рисуется, он только хранит данные. Точно так
же как `String` хранит текст, и его на экране не напишешь. Чтобы написать
на экране текст, нужен `Label` или какой-то подобный компонент.

Для отображения `Image` используется `ImageView`, это уже компонент, который
можно добавить на панели (`HBox`, `VBox`, `GridPane` и т.п.). Ему указывается,
какое изображение (Image) он должен отображать, и при необходимости можно
заставить его отображать только часть картинки, для этого указывается
прямоугольная область внутри картинки, которую должно быть видно.

Перечислим свойства компонента `ImageView`. Напомню, что свойства можно
прочитать и установить с помощью методов начинающихся на `get-` и `set-`.
Некоторые свойства вам не понадобятся, но полезно знать, что они есть.

* `fitWidth` и `fitHeight` — это ширина и высота, в которую будет врисована
картинка. Это не то же самое что размер картинки, потому что вы можете
показывать большую картинку в маленькой области на экране, `ImageView`
самостоятельно ее масштабирует до размеров 

    Обратите внимание, что это уже третий размер картинки: у картинки есть
    оригинальный размер, с которым она хранится на диске. Второй размер —
    это размер, с которым она загружена в память и хранится в памяти.
    Третий размер — это размер, с которым она показывается на экране.
* `preserveRatio` нужно ли сохранить соотношение сторон изображения при 
вписывании его в прямоугольник `fitWidth` на `fitHeight`. Если это свойство
установлено в `true`, то видимый размер изображения обычно будет меньше,
чем `fitWidth` на `fitHeight`, чтобы не растягивать изображение.
* `smooth` сглаживать ли изображение, это замедляет рисование, если необходимо
 изменить размер изображения при рисвании, но результат красивей.
* `image` — это то самое изображение, которое нужно показывать. Вообще, это
самое главное свойство. При вызове конструктора `ImageView` можно сразу его
укзать.
* `viewport` — прямоугольник внутри изображения, который надо показывать.
По умолчанию показывается всё изображение.

У `ImageView` нет собственной высоты и ширины, свойства `fitWidth` и `fitHeight`
не считаются — они задают размер области, куда вписывать изображение, 
а не реальный видимый размер изображения. Это может усложнить иногда
позиционирование изображения, например, нет простого способа показать
 его в центре нужной вам области. К счастью, в наших заданиях нам это не
 понадобится.
 
## `WritableImage`

Этот класс является наследником `Image`, т.е. это изображение, которое,
в частности, можно показывать с помощью `ImageView`. У `WritableImage`
можно вручную управлять цветами пикселей. До этого, напомню,
мы только читали готовые изображения из файлов или из Интернета.

Вот пример кода, который создает изображение и заполняет его зеленым цветом:

Cоздадим изображение размером 100 на 100 пикселей:

```WritableImage wi = new WritableImage(100, 100);```

Получим специальный объект, который дает доступ к записи отдельных 
пикселей:

```PixelWriter pw = wi.getPixelWriter();```

В цикле переберем все пиксели и назначим каждому красный цвет:

```
не готово
for (int x = 0; x < 256; x++)
    for (int y = 0; y < 256; y++)
        pw.setColor(x, y, Color.color(0, x / 255., y / 255.));
```
